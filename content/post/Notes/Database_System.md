---
author: "Yiming Shen"
date: 2022-03-15
lastmod: 2022-06-15
title: "数据库系统导论笔记"
tags: [
   "SQL",
    "Note",
]
categories: [
    "Notes", 
"Courses",
]
math: true
ShowToc: true
draft: false
typora-root-url: ..\..\static\
---

## 1 基本概念

1. 描述事物的符号记录叫数据

2. 数据库是长期储存在计算机内、有组织的、可共享的大量数据的集合。

   > 较小的冗余度、较高的数据独立性、易扩展性。

3. 数据库管理系统是位于用户与操作系统之间的一层数据管理软件。

4. 数据库系统是由数据库、数据库管理系统、应用程序和数据库管理员组成的存储、管理、处理和维护数据的系统。

5. 数据库系统的特点

   > 1. 数据结构化
   > 2. 数据的共享性高，冗余度低，易扩充
   > 3. 数据的独立性高
   > 4. 数据由DBMS统一管理和控制

6. 数据库管理系统的三个阶段

   1. 人工管理阶段
   2. 文件系统阶段
   3. 数据库系统阶段

7. 概念模型

   > 概念模型是现实世界到机器世界的一个中间层次。概念模型用于信息世界的建模，是数据库设计人员进行有力工具，也是数据库设计人员和用户之间进行交流的语言。
   >
   > - 实体：客观存在并可以相互区分的事物叫实体。
   > - 实体型：用实体名及其属性名集合来抽象和刻画同类实体
   > - 实体集：同型实体的集合称为实体集
   > - 实体之间的联系：实体内部的联系与实体之间的联系  

8. 数据模型

   > 数据模型通常由数据结构、数据操作和完整性约束三部分组成。

9. 关系模型

   > - 与非关系模型不同，它具有严格的数学基础
   > - 概念单一，数据结构简单
   > - 关系模型的存取路径对用户透明，从而具有更高的数据独立性、更好的安全保密性，也简化了程序员的工作和数据库开发建立的工作。
   
10. 三级模式、二级映像

   > 1. 模式：逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，**是所有用户的公共数据视图**。
   > 2. 外模式：用户模式，是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，**是数据库用户的数据视图**，是与某一应用有关的数据的逻辑表示。
   > 3. 内模式：存储模式，一个数据库只有一个内模式，是数据物理结构和存储方式的描述，**是数据在数据库内部的组织方式**。
   > 4. 外模式-模式映像：通过对该映像的调整，当模式改变时，外模式保持不变，应用程序不必修改，保证了数据与程序的逻辑独立性，简称**数据逻辑独立性。**
   > 5. 模式-内模式映像：通过对该映像的调整，当内模式（存储结构）改变时，可以使模式保持不变，应用程序也不变，保证了数据与程序的物理独立性，简称**数据的物理独立性**。

## 2 关系数据库

![image-20220613152900992](/../../static/Database_System.assets/%7D/image-20220613152900992.png)

### 概念

1. 关系模型的三个组成部分：关系数据结构、关系操作集合和完整性约束三部分组成

2. 三类关系：基本关系（基本表）、查询表和视图表

3. 基本关系6条性质：

   > 1. 列是同质的（数据类型相同）
   > 2. 不同的列可出自同一个域
   > 3. 列的顺序可随意交换
   > 4. 行的顺序可随意交换
   > 5. 任意两个元组的候选码不能取相同的值
   > 6. 分量必须取原子值
   
4. 三类完整性约束：实体完整性约束，参照完整性约束，用户自定义完整性约束。

### 关系操作

>选择，投影，并，差，笛卡尔积是五种基本操作

1. **传统的集合操作**：二目运算，并查交笛卡尔积
2. **专门的关系运算**：

$$
\sigma \quad 选择\\\\
\pi \quad 投影\\\\
\bowtie \quad 连接\\\\
\div \quad 除
$$

连接和除是复合运算

### 记号

$$
设关系模式为R(A_1,A_2,\cdots,An)\\\\
A_i A_i \cdots 为属性列\\\\
R(X,Z) \\\\
t[X]=x \quad Z_x = \{t[Z]|t\in R ,t[X]=Z\}
$$



#### 选择

在关系R 中选择满足给定条件的诸元组

F为选择条件 取值真或假

查询IS系全体学生：
$$
\sigma_{Sdept='IS'}(Student)
$$

#### 投影 

从关系R中选择出若干属性列组成新的关系
$$
\pi_A(R)=\{t[A]|t\in R\}
$$
A为R中的属性列

> 投影操作主要是从列的角度进行运算

查询学生的姓名和所在系:
$$
\Pi _{Sname,Sdept}(Student)
$$
可以去重(如查询学生关系中全部系名)，**去掉了标识元组的主码**。

#### 连接

从两个关系的笛卡尔积中选取属性间满足一定条件的元组 **(有条件的笛卡尔积运算)** 
$$
R \bowtie S = \{\}
$$

##### 等值连接

##### 自然连接

> 两个关系比较的**分量是相同的属性组**，结果中把重复的属性列去掉

把相同的连一块

##### 区别

等值连接可比即可 自然连接必须相同

等值连接m+n列 自然连接u-b列

##### 悬浮元组

> 两个关系R和S在做自然连接时，关系R中某些元组有可能在S中**不存在公共属性上值相等的元组**，从而造成R中这些元组在操作时被舍弃了，这些被舍弃的元组被称为悬浮元组。

##### 外连接

> 如果把悬浮元组也保存在结果关系中，而在其他属性上填空值Null，就叫做外连接

左外连接

只保留左边关系R中的悬浮元组

#### 除运算

> 给定关系R（X，Y） S（Y，Z）其中X，Y，Z为属性组
>
> R中的Y和S中的Y可以有不同的属性名，但必须出自相同的域集



条件 元组在X上分量值x的象集Yx包含S在Y上投影的集合

记作
$$
R \div S
=\{t_r [X] | t_r \in R \wedge  \Pi_Y (S)\subseteq Y_x\}
$$


##### 查询至少选修1号课和3号课的学生号码



##### 基本运算导出

$$
R(X,Y)\quad S(Y,Z)\\\\
P(X,Y)=\Pi_X(R)\times \Pi_Y(S)\\\\
\Pi_x(R)-\Pi_x(P(X,Y)-R(X,Y))
$$

### 例题6

$$
求供应工程J1红色零件的供应商号SNO\\\\
\Pi_{SNO}(\Pi_{SNO,PNO}(\sigma_{JNO='J1'}(SPJ)\bowtie\Pi_{PNO}(\sigma_{COLOR='红'}(P)))
$$



## SQL 概述



### SQL的产生和发展

> 结构化查询语句，任何商业化的数据库都支持SQL语句。

### SQL的特点

> 1. **综合统一**
> 2. 高度的非过程化
> 3. 集合操作
> 4. 一种语言，多种实现方式（嵌入式语言）
> 5. 语法简单

<h3 style="color:green">SQL的基本概念</h3>

#### SQL 支持三级模式

> 外模式、模式、内模式

视图－>基本表－>存储文件

#### 基本表

- **独立存在的表**
- SQL中一个关系对应一个基本表
- 一个或多个基本表对应一个存储文件
- 一个表可以带若干索引

#### 视图

- 从一个或几个基本表导出的表
- 数据库**只存放视图的定义**而不放对应数据
- 是**虚表**，只有结构
- 用户可以在视图上再定义视图

#### 存储文件

- 逻辑结构组成内模式
- 对用户不可见

## 学生－课程数据库

学生-课程模式 S-T

## 数据定义

### 模式的定义与删除

##### 模式

> - 一个DBMS可以建立多个数据库
> - 一个数据库中可以建立多个模式
> - 一个模式下通常可以包括多个表、视图、索引等数据库对象

定义模式

```sql
CREATE SCHEMA <NAME> AUTHORIZATION <USERNAME> [<表定义子句> <视图定义子句> <授权定义子句>];
```

- 定义模式实际定义了命名空间

##### 例题

```sql
CREATE SCHEMA "S-T" AUTHORIZATION WANG; 
```

*省略模式名：默认模式名为用户名*

**删除模式**

```sql
DROP SCHEMA <schemaname> <CASCADE | RESTRICT>;
```

`RESTRICT`: 限制非空模式的删除

`CASCADE`: 级联，删除模式同时把该模式的所有数据库对象删除

```sql
DROP SCHEMA zhang CASCADE
```

### 基本表的定义、删除与修改

```sql
CREATE TABLE <tablename> (<colname> <datatype> [<列级完整性约束条件> <列名> <数据类型> [<列级完整性约束条件>...] [<表级完整性约束条件>]])
```

#### 例

```sql
CREATE TABLE Student(
	Sno CHAR(9) PRIMARY KEY,
    Sname CHAR(20) UNIQUE, # 用户自定义完整性
    Ssex CHAR(2),
    Sage SMALLINT, 
    Sdept CHAR(20)

)
```



``` sql
CREATE TABLE Course(
	Cno		Char(4)	PRIMARY KEY,
    Cname 	CHAR(40),
    Cpno	CHAR(4),
    Ccredit	SMALLINT,
    FOREIGN KEY (Cpno) REFERENCES Course (Cno)
    
)
```



```sql
CREATE TABLE SC
(
	...
    PRIMARY KEY (Sno, Cno),
    FOREIGN KEY (Sno) REFERENCES Student(Sno)
)
```

#### 数据类型

- SQL中的域的概念是由数据类型实现的
- 确定运算性质
- 限定取值范围

#### 模式与表

>  一个基本表属于某个模式，一个模式可以包含多个基本表。 

**定义基本表所属模式**

1. 在表名中明显的给出模式名
2. 在创建模式语句中同时创建
3. **设置所属模式**（常用方法）



显示当前搜索路径

```sql
SHOW search_path
#default: $user,Public
```

#### 修改基本表

```sql
ALTER  TABLE <tablename> [ADD [COLUMN] <新列名> <数据类型> [完整性约束]] [ADD <表级完整性约束>] 
[DROP [COLUMN] <列名> [CASCADE | RESTRICT]]
[DROP CONSTRAINT <完整性约束名> [CASCADE | RESTRICT]]
[ALTER COLUMN <列名> <数据类型>]
```

##### 向学生表加入入学时间列

```sql
ALTER TABLE Student ADD S_entrance DATE;
```

##### 将年龄数据类型改为整型

```sql
ALTER TABLE Student ALTER smallint;
```

### 索引的建立与删除

> - 建立索引(数据库管理员、表的属主)
> - 维护索引（关系数据库管理系统）
> - 使用索引（关系数据库管理系统自动选择合适的索引）

#### 建立索引

```sql
CREATE [UNIQUE] INDEX <索引名> ON <表名>(<列名>[<次序>][,<列名>[<次序>]]…)
```

##### 例

按学号升序排列建唯一索引

```sql
CREATE UNIQUE INDEX Stusno ON Student(Sno ASC);
```

`ASC`升序（默认）`DESC`降序

#### 修改索引

```sql
ALTER INDEX <旧索引名> RENAME TO <新索引名>
```

> 没必要修改索引内容，重建即可。

#### 删除索引

```sql
DROP INDEX <索引名>
```

> 系统从**数据字典**中删去有关该索引的描述。

### 数据字典

> 关系数据库管理系统内部的一组系统表，记录了数据库中所有的定义信息：
>
> - 关系模式
> - 视图
> - 索引
> - 完整性约束
> - 用户对数据库的操作权限
> - 统计信息



## 查询



### 带有比较运算符的子查询

> 找出每个学生超过自己选修课程平均成绩的课程号

```sql
SELECT Sno,Cno
FROM SC x
WHERE Grade >= (SELECT AVG(Grade)
               FROM SC y
               WHERE y.Sno=x.Sno)
```

*相关子查询*

### ANY或ALL谓词子查询

> 必须同时使用比较运算

- \> ANY 大于子查询结果中的某个值
- \< ALL 小于查询结果中的所有值

> 查询非计算机系比计算机系任意一个学生年龄小的学生姓名和年龄

```sql
SELECT Sname,Sage
FROM Student
WHERE Sdept<>'CS' AND
	  Sage<ANY(SELECT Sage
              	FROM Student
              	WHERE Sdept='CS');
```

执行内嵌子查询不依赖父查询 👉 不相关子查询



#### 与聚集函数的等价转换关系

|      | =    | <>或!= | <    | <=    | >    | >=    |
| ---- | ---- | ------ | ---- | ----- | ---- | ----- |
| ANY  | IN   | --     | <MAX | <=MAX | >MIN | >=MIN |
| ALL  | --   | NOT IN | <MIN | <=MIN | >MAX | >=MAX |

### 带有EXISTS谓词的子查询

> **存在量词**
>
> - 带有`EXISTS`的子查询不返回任何数据，只判断T或F，内层查询非空为真
>
> - 由`EXISTS`引出的子查询，其目标列表达式通常都用*

查询了所有选修1号课程的学生姓名

```sql
SELECT Sname
FROM Student
WHERE EXISTS(SELECT *
             FROM SC
             WHERE Sno=Student.Sno AND Cno='1');
```

**所有IN、ANY、ALL、比较运算都能用EXISTS等价替换**

SQL 语言没有全称量词$$\forall $$

### 集合查询

`UNION` `INTERSECT` `EXCEPT		`

并	差	交

### 基于派生表的查询

> 子查询可以出现在FROM子句中，生成**临时派生表**作主查询的查询对象。



```sql
SELECT Sno, Cno
FROM SC, (SELECT Sno,Avg(Grade)
         FROM SC
          GROUP BY Sno
         ) AS Avg_sc(avg_sno,avg_grade)
WHERE SC.Sno = Avg_sc.avg_sno AND
	  SC.Grade >= AVG_sc.avg_grade;
```

**`FROM`中的嵌套查询子句需要`AS`定义派生表名**

无聚集函数可以不指明所有的列及列名

### `SELECT`语句的一般形式

```sql
SELECT [ALL|DISTINCT]
FROM <tablename>
WHERE <conditions>
GROUP BY <columnname> [HAVING <conditions>]
ORDER BY <columname> [ASC|DESC];
```

子查询不用`ORDER BY`

## 数据更新

### 插入数据

- 插入元组
- 插入子查询结果

**格式**

`INSERT` `INTO` `VALUES`

**例** 插入新元组至Student表中

```sql
INSERT
INTO SC(Sno,Cno)
VALUES ('201215128','1');
```

如果是完整的插入，无需指明哪几列

#### 插入子查询的结果

**例** 求各系学生平均年龄，存入数据库

```sql
CREATE TABLE Dept_age
(
    Sdept	CHAR(15)
    Avg_age	SMALLINT
);

INSERT
INTO	Dept_age(Sdept,Avg_age)
SELECT	Sdept,AVG(Sage)
FROM	Student
GROUP	BY	Sdept;
```

#### 插入数据的完整性约束

> DBMS在插入语句时会检查插入操作是否破坏已定义的完整性规则

- 实体完整性
- 参照完整性
- 用户定义的完整性
  - `NOT NULL`约束
  - `UNIQUE`约束
  - 值域约束

### 修改数据

```sql
UPDATE <tablename> SET
```

```sql
UPDATE Student
SET Sage = 22
WHERE Sno ='837728921019'
```

#### 带子查询的修改语句

**例** 将计算机系全体学生成绩归零

```sql
UPDATE SC
SET Grade = 0
WHERE Sno IN
(
    SELECT	Sno
    FROM	Student
    WHERE	Sdept='CS'
);
```

#### 完整性约束

同插入

### 删除数据

```sql
DELETE
FROM	<表名>
[WHERE	<条件>];
```

#### 功能

- 删除指定表中满足条件的元组
- 表的定义仍在字典中

`DROP`删整张表

## 空值的处理

> 空值就是不知道、不存在或无意义的值。

- 该属性本来有一个值，但目前不知道（新生的班级）
- 不应该有值
- 不便于填写

**空值是特殊的值，含有不确定性，关系运算需要做特殊处理。**

**例** 插入学号、课程号、成绩的元组

```sql
INSERT INTO SC(Sno,Cno,Grade)
VALUES('201215126','1',NULL);
```

### 视图

- 虚表
- 数据库只存放视图的定义，不存放视图对应的数据
- 基本表中数据发生变化，视图也发生变化

#### 建立视图

```sql
CREATE VIEW <viewname>
AS <sonquery>
[WITH CHECK OPTION];
```

**子查询**

- 可以是任意的`SELECT`语句

**组成视图的属性列名，可以全部省略或明确指定视图的所有列名**

**例** 建立一个信息系学生的视图

```sql
CREATE VIEW IS_Student
AS
SELECT Sno,Sname,Sage
FROM STUDENT
WHERE Sdept = 'IS';

WITH CHECK OPTION; /*对该视图进行更新操作时RDBMS会自动加上Sdeptd='IS'这个条件*/
```

**`IS_Student`视图是行列子集视图**



## 第五章 数据库完整性



### 数据库完整性概述



### 实体完整性

### 参照完整性

### 用户自定义完整性

### 完整性约束子句

### 断言

### 触发器



## 第六章 关系数据理论

### 基本概念

1. 函数依赖：
$$
   R(U)是一个关系模式，U是R的属性集合，X和Y是U的子集。\\\\
   对于R(U)的任意一个可能的关系r，若r中不存在两个元组，它们\\\\
   在X上的属性值相同而在Y上的属性值不同，则称X函数确定Y\\\\
   或Y函数依赖于X，记作X\rightarrow Y
$$

   > 即若存在X确定Y，则任意两个元组在X上的属性值相同，那么他们在Y上的属性值也一定相同。

2. 完全/部分函数依赖（X的每一个真子集都能确定Y就是完全函数依赖）

3. 传递依赖
$$
   在R(U)中，X\rightarrow Y,Y不含于X，Y不能确定X，Y能确定Z，Z不含于Y\\\\
   则称Z对X传递函数依赖。
$$

4. 候选码，主码：K能确定U，则K为R的候选码，多于一个候选码，则选定其中一个为主码。

5. 外码：不是R的码，是另一个关系模式的码，则称X是R的外部码，也称外码。

6. 全码：整个属性组都是码。

7. 第一范式1NF：如果一个关系模式R的所有属性都是不可分的基本数据项，则R 属于 1NF

   不满足第一范式的数据库不能称为关系数据库。

8. 2NF：R属于1NF且每一个非主属性都完全函数依赖于R的码，则为2NF

9. 3NF：R中不存在Z对码X传递依赖，也不存在部分函数依赖于X。

10. BCNF：R属于1NF，能确定其他属性集合的X一定是码，则为BCNF

### 证明

1. 如果R是BCNF关系模式，则R是3NF关系模式，反之则不然。
2. 如果R是3NF关系模式，则R一定是2NF关系模式。



## 第七章 数据库设计



### 数据库设计过程

1. 需求分析
2. 概念结构设计
3. 逻辑结构设计
4. 数据库物理设计
5. 数据库实施
6. 数据库运行和维护

### 数据库概念结构

#### 主要特点

1. 真实、充分的反映现实世界事物之间的联系
2. 易于理解
3. 易于更改
4. 易于向关系、网状、层次等各种数据模型转换。

#### 设计策略

1. 自顶向上
2. 自底向上
3. 逐步扩张
4. 混合策略

### 绘制E-R图

略

### E-R图转关系模型

略

### 逻辑结构设计

> 将概念结构设计阶段设计好的基本E-R图转换为与选用的DBMS产品所支持的数据模型相符合的逻辑结构。

1. 将概念结构转换为关系模型
2. 对数据模型进行优化

### 物理设计

> 为给定的逻辑数据模型选取一个最适合应用要求的物理结构

1. 确定数据库的物理结构（在关系数据库中主要指存取方法和存储结构）
2. 对物理结构进行评价，评价的重点是时间和空间效率。

## 第9章 关系查询处理和查询优化



### 查询树的启发式优化

- 选择运算应尽可能先做
- 把投影运算和选择运算同时进行
- 把投影同其前或后的双目运算结合起来
- **把某些选择同在它前面要执行的笛卡尔积结合起来成为一个连接运算**
- 找出公共子表达式

#### 具体方法

1. 利用等价变换规则，把形如

$$
\sigma_{F_1 \wedge F_2 \wedge \cdots\wedge F_3}(E)
$$
​			的表达式变换成
$$
\sigma_{F_1}(\sigma_{F_2}(\cdots(\sigma_{F_n}(E)))
$$
2. 对每一个选择，利用等价变换规则尽可能将其移到树的叶端。
2. 对每一个投影，利用等价变换规则尽可能将其移到树的叶端。
2. 选择和投影串联合并成单个的或一个选择后跟一个投影，使其能同时执行，或在一次扫描中全部完成。
2. 语法树内节点分组，每一双目运算和它所有的直接祖先为一组。