---
author: "Yiming Shen"
date: 2022-03-15
lastmod: 2022-03-15
title: "计算机组成原理笔记"
tags: [
   "408",
    "计组",
    "Note",
]
categories: [
    "Notes", 
"Courses",
]
math: true
ShowToc: true
draft: false
typora-root-url: ..\..\static\
---

> **2022.3.15**

 ## 浮点数

### 原码一位乘

部分积累加、移位

乘积
$$
P = |X|\times |Y|\\\\
S_p=S_X异或S_Y
$$


手工运算和十进制乘法类似

> 每次将1位乘数所对应的部分积与原部分的累加和相加，并移位

#### 设置寄存器

A：存放部分**积累加和，乘积高位**

B：存放**被乘数**

C：存放**乘数、乘积低位**

最后符号异或。



### 补码一位乘法

#### Booth 比较法

$$
[XY]_补 ＝[X]_补[0.Y_1Y_2\cdots Y_n]-[X]_补Y_0
$$

| Yn高位 | Yn+1低位 | 运算操作  |
| ------ | -------- | --------- |
| 0      | 0        | 1/2 * A补 |
| 0      | 1        | 1、2      |
| 1      | 0        |           |
| 1      | 1        |           |



#### 例题

X＝-0.1101 Y=-0.1011 计算[XY]补

初始化A＝00.0000

B=X=11.0011

-B=-X=00.1101

C=Y=1.0101

#### 原码两位乘法 （略）

### 定点数的除法

<h4 style="color: red">补码不恢复余数除法</h4>

([X]<[Y])
$$
被除数X_补 \quad 除数Y_补\\\\
余数r_i=0,1,\cdots
$$

$$
r_0=X_补 比较r_0与Y_补符号\\\\
同号上商1 异号上商0
$$

| r/Y补 数符 | 商   | 对应操作            |
| ---------- | ---- | ------------------- |
| 同号       | 1    | ri+1=2*\|ri\|补-Y补 |
| 异号       | 0    | ri+1=2*\|ri\|补-Y补 |

商修正：符号位+1 末尾恒置1

余数修正： 左移了n次，则余数＝2^n * rn



#### 补码恢复余数除法（用的少）



#### 原码恢复/不恢复余数除法（不要求）



### IEEE754 浮点四则运算

#### 实现

> 1. 通过子程序
> 2. 通过浮点处理器
> 3. 通过专门的浮点运算部件

#### 运算

浮点数运算👉尾数运算、阶码运算

尾数加减乘除  阶码移码加减

#### 短浮点数阶码加减

*偏移127*
$$
E_b = E_x+E_y+129(mod\quad 2^8)
$$
原理推导：
$$
[E_x+E_y]_移 = 127+(E_x+E_y)=(127+E_x)+(127+E_y)-127
$$

#### 浮点数的加减

移位操作 尾数原码加减

1. 检测是否能简化操作（尾数是否为0 有无下溢）

2. 计算阶差

3. 对阶（使阶数增大）

   > 低位向高位看齐，右移时补1以减少误差

   目的：使两数阶码相等，减少误差。

4. 尾数加减

5. 结果规格化

   > 使1<|M|<2

#### 浮点数乘法

$$
A=2^{AE}\times A_M 
$$

#### 浮点数除法

---

## 数据的校验

### 奇偶校验

> 增设1位校验位，从而使1的个数是奇或偶数

### 海明校验

> - 多重分组奇偶校验
> - 若干分组，每组都进行奇偶校验
> - 能够检验是否出错，也能定位出错位

[假设] 待编码信息K位 分成r组，每组1个校验位

校验码位数 r位；

海明编码总长：N=k+r位

海明编码时，各组单独进行奇偶校验编码，确定编码位



#### 指误码

代码检验时 每组能产生1个错误码

r位指误码

2^r种可能的错误代码

**指误码全为0则无错**

各参数应满足：
$$
N = k+r\le 2^r-1
$$

#### 分组方法

> 有效信息：A1A2A3A4 校验位：P1P2P3 偶校验

| 1    | 2    | 3    | 4    | 5    | 6    | 7   |
| ---- | ---- | ---- | ---- | ---- | ---- | ----|
| P1   | P2   | A1   | P3   | A2   | A3   | A4 |
|      |      |      | √ | √ | √ | √ |
|      | √ | √ |      |      | √ | √ |
| √ |      | √ |      | √ |      | √ |
| 1 | 0 | 0 | 1 | 0 | 1 | 1 |
| 1 | 0 | 0 | 1 | **1** | 1 | 1 |



*还有指误码*

> - 对码字的位从1到n编号 并表示为二进制数
> - 对2的每一个幂(1,2,4…)设置一个奇偶位，其他位置存放数据。

0011 的海明码

| 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| C1   | C2   | 0    | C4   | 0    | 1    | 1    |

C1 = 3 xor 5 xor 7 ＝ 1

C2 = 3 xor 6 xor 7 ＝ 0

C4 = 5 xor 6 xor 7 ＝ 0

横坐标是信息 纵坐标是第几次校验

#### 海明码的纠错过程

> 形成新的检测位P_i

（不能连错两个）

### 循环冗余校验码（CRC码）

#### 基本思想

> 数据发送、接收方约定一个二进制除数
>
> K个信息位+R个校验位作为被除数，添加校验位后需保证除法得余数为0
>
> 收到数据后，进行除法检查余数是否为0
>
> 若余数非0则说明出错，进行重传或纠错。

#### CRC码的生成

##### 1. 确定K、R以及生成多项式对应的二进制码

$$
G(x)=x^3+x^2+1\\\\
1101
$$

K = 信息码的长度 = 6 

R = 生成多项式最高次幂 = 3

N = K + R = 9

##### 2. 移位

信息码左移R位，低位补0

##### 3. 相除

对移位后的信息码，用生成多项式进行模2除法，产生余数
$$
101001000/1101\\\\
$$

##### 4. 检错和纠错

用二进制码进行模2除，余数为000，代表没有出错

| 余数    | 出错位 |
| ------- | ------ |
| 001     | 1      |
| 010     | 2      |
| 100     | 3      |
| 101     | 4      |
| 111     | 5      |
| 011     | 6      |
| 110     | 7      |
| **001** | **8**  |
| **010** | **9**  |

三位校验码只能表示7位出错位

**条件**

> $$
> 2^R\ge K+R+1
> $$

*实际应用中一般只用来检错*

#### 作用

1. 可以检测出所有奇数个错误
2. 可以检测出所有双比特错误
3. 可检测出所有小于等于校验位长度的连续错误
4. 若选择合适的生成多项式，且满足条件(11) 可纠正单比特错

## 算术逻辑单元 ALU

> 算术运算：加减乘除
>
> 逻辑运算：与或非异或
>
> 辅助功能：移位、求补等

 机器字长：计算机能够同时处理多少个bit的计算

ALU和寄存器位数相同 = 机器字长

ALU需要输入信号、输出信号、控制信号

### 基本逻辑运算

> 与或非

### 一位全加器

$$
A_i加数A\quad B_i加数B\\\\
C_{i-1}来自低位的进位\quad S_i本位的和
$$

输出
$$
S_i:输入中有奇数个1时为1（异或）\newline
S_i = A_i\oplus B_i \oplus C_{i-1}\\\\
C_i:输入中至少有2个1\newline
C_i = A_iB_i+(A_i\oplus B_i)C_{i-1}
$$


## 微程序控制器



### 时序部件

1. 时序信号

   > 周期、节拍、脉冲等频率型信号序列

   **时序发生器或时序系统**由一个低频振荡器和倍频逻辑组成。

   低频振荡器－>倍频逻辑－>CPU时钟周期信号->机器周期信号->指令周期信号

   系统时钟信号经过倍频放大后，产生执行指令所需要的各种时序信号

### CPU的工作原理

1. 主要功能

   - 处理指令
   - 执行操作
   - 控制时间
   - 数据运算

2. 执行指令的流程

   - 读取指令
   - 指令译码
   - 指令执行 － 寻址、取数、运算
   - 后续工作

3. 部件的控制方式

   1. 同步控制

      > 每步操作都向统一的外部时序信号对齐，各步操作无交互。

      时序简单、实现容易；但时间分配不合理。

      应用于CPU、内存、外设内部

   2. 异步控制方式

      > - 每步操作不需向统一的外部时序信号对齐
      > - 各步操作之间通过交互应答来实现协同

      三个操作靠相互之间的控制信号来实现协同。

      特点：时间分配合理

### 外部连接与I/O控制任务

#### 外部连接类型

   - 单处理机系统：通过**前端总线**与北桥芯片组连接
   - 多处理机系统：集成了PCI－E接口，CPU之间通过QPI、与芯片组之间通过DMI总线互联。

### 在I/O控制中的任务

主机<-接口->外围设备

> 主机与外设之间进行数据输入、输出操作时，在不同I/O控制模式下，CPU承担的任务各不相同

1. 程序传送模式：CPU直接执行I/O指令
2. 中断模式：CPU执行中断服务程序
3. DMA（直接内存访问）模式，CPU管理DMA控制器、善后处理
4. IOP（读写处理器）和PPU（外部设备处理单元）模式：CPU组织I/O程序，管理IOP与PPU，以及善后处理

### 指令系统

设计CPU的一般过程：

​		指令系统-> 数据通路-> 控制器-> CPU定型

> CISC －> RISC
>
> 1. CISC中不同指令使用频率悬殊
> 2. 不利于VLSI工艺
> 3. 主存技术的发展

#### 指令格式

1. 字长

   - 定长指令格式 规整、便于控制
   - 变长指令格式 合理利用存储空间，提高取指令效率

2. 操作码结构

   - 定长操作码

     各指令0的位置、位数固定相同

   - 扩展操作码

     各指令0的位置、位数不固定，根据需要变化

#### 常见的地址结构类型



- 四地址结构指令

  0 A1 A2 A3 ~~A4~~

- 三地址结构指令

  0 操作数地址 结果地址

- 二地址结构指令

  0 目的地址 原地址

  一地址结构指令

  0 源/目的地址

  隐含约定： $$ A1 \or [PC]_H -> PC  \\\\   J add r $$

- 零地址结构指令

  功能：

  - 用于处理机的特殊控制 HLT NOP
  - 针对隐含约定的寄存器，如返回指令



#### 指令可能涉及到的操作数类型

地址码 数值型 字符型 逻辑型



### 指令中的寻址方式 

> 



#### I/O指令设计思路

思路1：设计专用的I/O指令



思路2: 用传送指令替代I/O指令



#### 算术逻辑运算指令

1. 算术运算指令
2. 逻辑运算指令

#### 程序控制类指令

主要作用：控制指令的执行流程

1. 转移指令

2. 无条件转移 操作码 －转移地址

   条件转移：操作码－转移地址+转移条件PSW

   循环：转移条件为循环技术值

3. 转子指令与返回指令

   转子: 即调用，操作码+子程序入口

   返回：操作码+返回地址（**堆栈的顶单元中**）

   同一条返回指令应能提供多个不同的返回地址（条件返回）
