---
author: "Yiming Shen"
date: 2022-05-24
lastmod: 2022-05-24
title: "应用密码学复习提纲"
tags: [
   "Cryptology",
    "review",
    "Note",
]
categories: [
    "Notes", 
"Courses",
]
math: true
ShowToc: true
draft: false
typora-root-url: ..\..\..\static\
---

## 提纲

1. 古典密码学 Caesar Playfair **Hill** 维吉尼亚 **Affine**
2. **分组密码** Feistel网络结构 DES
3. 群环域 **域上的乘法** AES
4. **公钥密码** RSA EIGamal
5. 椭圆曲线 密钥交换协议Diffie-Hellman
6. Hash函数 SHA1 SHA256 MD5
7. 数字签名 RSA EIGamal



## 分组密码

> 分组密码是一种加/解密算法，将输入的明文分组当作一个整体处理，输出一个等长的密文分组。

### Feistel 密码结构

> 对理想分组密码的近似

![image-20220528001126847](/Cryptology.assets/%7D/image-20220528001126847.png)

使用**乘积密码**增强密码强度，交替使用代换和置换，增强密码的**扩散**和**混淆**性能。

**密钥和密文关系为非线性关系**

**混淆（Confusion）**：使密钥与密文的关系尽可能模糊，使用替换法达到目的。

**扩散（Diffusion）**：隐藏明文的统计特性，使用位置换达到目的。

#### 优点：

- 对称密码结构，加密解密过程几乎一样
- 编码量和线路传输的要求少了几乎一半

### Feistel 密码结构

- 分组长度
  - 分组越长代表安全性越高（扩散性能越好），但会降低加解密速度。
- 密钥长度
  - 密钥越长安全性越高（抗穷举、提高混淆）
- 迭代轮数
  - 多轮加密可取得较高的安全性

**Feistel密码通常由以下步骤组成**

1. 子密钥生成算法
2. 轮函数
3. 快速软件加解密
4. 简化分析难度

### 数据加密标准 DES

![img](https://www.ruanx.net/content/images/2020/04/figure2-des_block.gif)

![img](https://images2018.cnblogs.com/blog/1281268/201807/1281268-20180720073949486-1474910065.png)

![img](https://www.ruanx.net/content/images/2020/04/image-2.png)



- 算法分为两部分：**迭代加密**、**密钥调度**

　　所谓密钥调度，就是从一把 64-bit 的主钥匙，得到 16 把 48-bit 的子钥匙，然后把这些子钥匙用于迭代加密。那么，如何从一把主钥匙得到 16 把子钥匙呢？

1. 从 64-bit 的主钥匙里面选取特定的 56 位，其余的位就没用了。于是我们现在手上有了一个 56 位的布尔数组。把它分成左、右两个半密钥，它们都是 28-bit 的布尔数组。
2. 左、右两个半密钥都左旋（也就是循环左移。整个数组往左移，左边弹出去了的东西补到最右边去）一定位数，这个左移的位数也是指定的。有些轮次是 1 位，有些轮次是 2 位。
3. 把左、右半密钥拼起来，再做一个置换，就得到了这一轮生成的子密钥。这个置换是从 56-bit 的数组里面选取指定的 48 位。所以现在每一轮都可以生成一个 48 位的子密钥。（注意，步骤 3 并不改变左右半密钥）。
4. 重复 步骤 2、步骤 3 一共 16 次，于是得到了 16 个 48-bit 的子密钥。

现在我们手上有了 16 把子密钥。遂开始加密：

1. 输入的明文（长度为 64 的布尔数组）做一个置换(IP置换)。仍然得到 64-bit 的数组（不然就丢失信息了！）

2. 把得到的数组拆成左、右两半边。每边是 32 位长度。

3. 每一轮迭代，都是接收一组 `L, R`，返回 `L', R'` ，作为下一轮迭代的 `L, R` . 迭代过程如下：
   L′=RR′=L⊕F(R,subkey)其中 F 函数（称为轮函数）是整个算法的核心，功能是：以一个子密钥，加密 32-bit 的信息。
   $$
   L'=R\\\\
   R'=L\oplus F(R,subkey)
   $$
   

4. 利用之前得到的 16 个子密钥，执行步骤 3 一共 16 次。

5. 将最终的 R 与 L 拼接，再做一次置换(FP置换)，即得到密文。

Feistel轮函数：

1. 扩展32位R至48位
2. 轮密钥XOR异或
3. S盒置换（8个S盒，每盒输入6位，输出4位）
4. P置换

> 一个 32-bit 的块，经过一个扩张(Expand函数)，变成 48 位，然后**与子密钥异或**。得到的 48-bit 的结果分为 8 组，每一组是 6-bit 的数据，丢进对应的 **S 盒**，输出 4-bit 的信息。把这些输出收集起来，一共是 4*8 = 32 位，做一次置换 (P 置换)，得到 32-bit 的结果。这与输进来的 32-bit 信息是等长度的。

S盒：

- S盒是对称密码系统分组加密算法中最核心的安全部件
- 6输入中的第1和第6比特组成的二进制数确定的行，中间4位二进制数确定列
- 相应位置的十进制数转为4位二进制数进行输出



> 雪崩效应：明文或密钥的某一位发生变化（微小的变化）将对密文的结果产生很大的影响。

#### DES的工作模式

1. **电子编码本 ECB**
2. **密码分组链接 CBC**
3. 输出反馈 OFB
4. 密码反馈 CFB

## 数字签名

> 数字签名是一种电子形式给一个消息签名的方法

签名：用**私钥**加密信息达到**身份验证**目的的运算

### 数字签名的目的

1. 提供一个手写签名的**数字化副本**

2. 数字签名保障了：

- 数据完整性
- 系统可用性
- 实体认证性
- 行为不可抵赖性

### 数字签名属性

1. 核实**作者签名和日期的时间**
2. 在签名时**对内容进行身份验证**
3. 为解决争端，能够被**第三方核查**

### 数字签名要求

1. 依赖于消息**位模式**
2. 使用特有的信息
3. 生成相对容易
4. 伪造在计算上不可行
5. 可以保留副本

### 数字签名方法

#### 普通数字签名

> **RSA EIGamal Schnorr** 椭圆曲线数字签名算法、**DSA数字签名算法**、有限自动机数字签名算法。

####  特殊数字签名

> 不可否认签名、门限签名、盲签名、代理签名

#### 功能：

1. 确认信息是由签名者发送（**实体认证性**）
2. 确认信息自签名到收到未被篡改（**数据完整性**）
3. 签名者无法否认签名由自己发送（**行为不可抵赖性**）

### 数字签名解决方案

#### 直接数字签名方案

> 前提：假设目标知道源的公钥 

- 只涉及通信的源点X和终点Y双方
- X的公钥$$K_{Ux}$$私钥$$K_{Rx}$$
- X可以使用私钥对消息报文的散列值进行加密来形成数字签名

##### 安全性

1. 安全性依赖于私钥的安全性
2. 但不具备行为不可抵赖性，即使每个报文中包含时间戳，仍可以被伪造。

#### 基于仲裁的数字签名方案

> 通过引入仲裁来解决直接签名方案中的问题，但仲裁者必须是一个受所有通信方信任的机构。

X->A->Y，A检验报文和签名的出处、内容，注明日期，加上仲裁证实标记。

#### 方案内容

1. **密钥生成**，如公钥密码体制
2. **签名算法**，利用私钥进行签名
3. **验证算法**，利用公钥验证签名

### RSA 数字签名

#### RSA 公钥算法

$$
大素数p、q \newline
n=p\times q\quad \phi(n)=(p-1)(q-1) \newline
随机正整数1<e<\phi(n),满足gcd(e,\phi(n))=1\newline
计算d 满足 d\times e =1(mod\quad\phi(n))\newline
加密变换： 对明文m\in Z_n, c=m^e (mod\quad n)\newline
解密变换： 对密文c\in Z_n, m=c^d (mod\quad n)
$$

> 手算RSA的前置技能：**模逆运算**（扩展欧几里得算法）**快速幂模运算**

#### 数字签名实现

密钥的生成完全相同，签名时：
$$
m\in Z_n, Sig(m)=m^d(mod \quad n)\newline
S\in Z_n, 若m=S^e (mod\quad n)，则认为s为消息m的有效签名
$$

### EIGamal 数字签名

#### 密钥参数生成

$$
选定大素数p\\\\
选取g,x<p\\\\
y=g^x(mod\quad p)\\\\
\{y,g,p\}即为公钥，x为私钥
$$

#### 签名过程

$$
K=公钥\{y,p,g\}私钥 x\\\\
签名算法：对随机数k,待签消息m，定义Sig(x,k)=(r,s)\\\\
r=g^k(mod\quad p),s=(m-xr)k^{-1}mod(p-1)\\\\
验证算法：Ver(m,r,s): y^rr^s\equiv g^m(mod\quad p)?true:false
$$

#### 注意

1. 每次签名应选择不同的随机数k，否则有可能私钥x能被算出
2. EIGamal 效率低于RSA 且有两倍的消息扩张
3. EIGamal数字签名也可以推广到合适的循环群中，某些变形能被证明在选择消息攻击下是安全的

